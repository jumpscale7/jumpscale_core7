#!/usr/bin/env jspython

from JumpScale.baselib import cmdutils
import JumpScale.baselib.jpackages
from JumpScale import j
import sys
import copy
j.application.start('jpackage')

parser = cmdutils.ArgumentParser()

commands = ['install','list','stop','start','restart','build',"mdupdate","update","reset","resetstate",\
    "removedata","monitor","configure","cleanup","export","import","uninstall","package","push","execute","create", "status"]

help="""
jpackage commands:

    install: 
    - download all related git repo's (if not downloaded yet, otherwise update)
    - prepare & copyfiles & configure
    - start the app
    list:
    - list the jpackages
    stop-start-restart 
    build
    - if build instructions are given the build repo's will be downloaded & build started
    - build happens to production dir
    package
    - copy the files which are relevant from building back to the binary repo
    mdupdate
    - update all git repo's which have jpackage metadata 
    update
    - go over all related repo's & do an update
    - copy the files again
    - restart the app
    reset
    - remove build repo's !!!
    - remove state of the app (same as resetstate) in jumpscale (the configuration info)
    - remove data of the app
    resetstate
    - remove state of the app (same as resetstate) in jumpscale (the configuration info)
    removedata
    - remove data of app (e.g. database, e.g. vmachine when node jpackage)
    execute
    - execute cmd on package e.g. sshcmd on node jp or sql statement on database ...
    - use --data with cmd:... to specify cmd to be execute
    monitor
    - do uptime check, local monitor & remote monitor check, if all ok return True
    configure
    - configure the app
    cleanup
    - remote old logfiles, ...
    export/import
    - use --url to specify where to import from or export to
    create
    - interactively create a jpackage
"""

parser.add_argument("action", choices=commands, help='Command to perform\n')

group = parser.add_argument_group(title="Package Selection")
group.add_argument('-q','--quiet', required=False, action='store_true', help='Put in quiet mode')
group.add_argument('-n','--name',required=False, help='Name of jpackage to be installed',default="")
group.add_argument('-d','--domain',required=False, help='Name of jpackage domain to be installed',default="")
group.add_argument('-i','--instance',required=False, help='Instance of jpackage (default main)',default="main")
group.add_argument('-f','--force',required=False, action='store_true',help='auto answer yes on every question')
group.add_argument('--nodeps',required=False, action='store_true',help='do action on dependencies, default True',default=False)
group.add_argument('--verbose', required=False, action='store_true',default=False, help='Verbose output.')

group.add_argument('--node',required=False,default=None,help='node on which to execute the action')
group.add_argument('--remote',required=False,default=False,action="store_true",help='execute from a remote machine')
group.add_argument('--lua',required=False,default=False,action="store_true",help='execute from actions.lua file')

#install
group = parser.add_argument_group(title="Install/Update/Expand/Configure")
group.add_argument('--data', required=False, help='use this to pass hrd information to jpackage e.g. \'redis.name:system redis.port:9999 redis.disk:0\'')
# group.add_argument('-r', '--reinstall', required=False, action='store_true', help='Reinstall found package')
# group.add_argument('-s', '--single', required=False, action='store_true', help='Do not install dependencies')

#install
group = parser.add_argument_group(title="Export/Import")
group.add_argument('--url', required=False, help='uncpath to export to or import from')

#list
group = parser.add_argument_group(title="List")
group.add_argument('--installed', required=False, action='store_true',default=None, help='List installed jpackages')

def getJPackage(args, installed=None,debug=None,update=False,expandInstances=True,toinstall=False,list=False):

    packages=[]

    name=args.name.strip()
    if name=="*":
        name=""
    
    if name!="" and name.find("*")==-1:
        for pname in args.name.split(","):
            if pname.strip()!="":
                packages += j.packages.find(name=pname.strip(), domain=args.domain)
    else:        
        packages += j.packages.find(domain=args.domain)
        if len(packages) > 1 and name.find("*")!=-1:
            tofind=name.replace("*","")
            packages=[item for item in packages if item.name.find(tofind)!=-1]

        if len(packages) > 1 and name.find("*")!=-1:
            pass #no need to ask interactive
        elif len(packages) > 1 and list==False:
            if not j.application.interactive:
                print(("Found multiple packages %s, cannot continue in non interactive mode" % (packages)))
                j.application.stop(1)
            else:
                packages = j.console.askChoiceMultiple(packages, "Multiple packages found. Select:")


    if len(packages) == 0:
        print(("Could not find package with name '%s' in domain '%s' " % (args.name, args.domain)))
        j.application.stop(1)

    if toinstall and args.instance<>"main" and len(packages)>1:
        raise RuntimeError("Can only get jpackage instances if only 1 jpackage when instance set or more jpackages when instance=main")
    
    if toinstall:
        packages=[jp.getInstance(args.instance) for jp in packages]

    if expandInstances:
        #find all instances
        pass
        #@todo
        
    #@todo fix
    if installed:
        if j.packages.type=="c":
            packages = [jp for jp in packages if j.system.fs.find(j.dirs.getHrdDir(), '%s.*' % (jp.name if hasattr(jp, 'name') else jp.jp.name))]
        else:
            packages = [jp for jp in packages if j.system.fs.find(j.dirs.getHrdDir(), 'jumpscale.%s.*' % (jp.name if hasattr(jp, 'name') else jp.jp.name))]
        packages = sorted(packages, key=lambda jp: jp.getProcessDicts(args=args)[0].get('prio', 100) if jp.getProcessDicts(args=args) else 100)

    if packages==[]:
        raise RuntimeError("Cannot find packages, need at least 1")

    return packages


if '--help' in sys.argv or '-h' in sys.argv:
    print help

args = parser.parse_args()
args.deps=not args.nodeps

hrddata={}
if args.data<>None:    
    if args.data.find("#")<>-1:        
        for line in args.data.split("#"):
            if line.find("=")<>-1:
                var,data=line.split("=",1)
                hrddata[var.strip()]=data.strip()
    else:
        tags=j.core.tags.getObject(args.data)
        hrddata=tags.getDict()

if args.node!=None:
    hrddata["node2execute"]=args.node
if args.lua!=None:
    hrddata["lua"]=args.lua

  
# def askDomains(args):
#     if args.domain==None:
#         return j.console.askChoiceMultiple(j.packages.getDomainNames())
#     else:
#         domains=args.domain.split(",")
#         domains=[domain.lower().strip() for domain in domains]
#     return domains

if args.verbose:
    j.application.debug=True

if args.quiet:
    class NullDevice():
        def write(self, s):
            pass
    sys.stdout = NullDevice();

if args.action == 'configure':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.configure(args=hrddata,deps=args.deps)
        package.start(args=hrddata)

elif args.action == 'install':

    packages = getJPackage(args,expandInstances=True,toinstall=True)
       
    # if args.instance<>0 and len(packages)>1:        
    #     j.events.inputerror_critical("Cannot find more jpackages if instance is given.")

    for package in packages:
        # dependencies = True
        # if args.single or args.deps:#args.deps because the cmdutils.getJPackage(...) will already have found the dependencies
        #     dependencies=False
        # if args.debug:
        #     package.setDebugMode()
        # download=True
        # if args.nodownload:
        #     download=False

        package.install(args=hrddata,deps=args.deps)

elif args.action == 'update':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.update(args=hrddata,deps=args.deps)

elif args.action == 'monitor':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    result=[]
    for package in packages:
        if package.monitor(args={},deps=args.deps)==True:
            result.append("OK    :%s"%package)
        else:
            result.append("ERROR :%s"%package)

    print "\n\nMONITORING RESULTS:"
    print "\n".join(result)

elif args.action == 'package':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.package(args={},deps=args.deps)

elif args.action == 'publish':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.publish(args={},deps=args.deps)

elif args.action == 'reset':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.reset(args={},deps=args.deps)

elif args.action == 'removedata':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.removedata(args={},deps=args.deps)

elif args.action == 'resetstate':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.resetstate(args={},deps=args.deps)

elif args.action == 'publish':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.publish(args={},deps=args.deps)

elif args.action == 'export':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.export(url=args.url,deps=args.deps)

elif args.action == 'import':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.iimport(url=args.url,deps=args.deps)

elif args.action == 'restart':
    packages = getJPackage(args,expandInstances=True,toinstall=True, list=True)
    for package in packages:
        package.restart(args=hrddata,deps=args.deps)

elif args.action == 'start':
    packages = getJPackage(args,expandInstances=True, installed=True, toinstall=True, list=True)
    for package in packages:
        package.start(args=hrddata,deps=args.deps)

elif args.action == 'stop':
    packages = getJPackage(args,expandInstances=True, installed=True, toinstall=True, list=True)
    packages.reverse()
    for package in packages:
        package.stop(args=hrddata,deps=args.deps)

elif args.action == 'execute':
    packages = getJPackage(args,expandInstances=True, installed=True, toinstall=True)
    for package in packages:
        package.execute(args=hrddata,deps=args.deps)

elif args.action == 'build':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.build(args=hrddata,deps=args.deps)

elif args.action == 'uninstall':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.uninstall(args=hrddata,deps=args.deps)

elif args.action == 'push':
    packages = getJPackage(args,expandInstances=True,toinstall=True)
    for package in packages:
        package.push(args=hrddata,deps=args.deps)

elif args.action == 'create':
    for instance in j.application.getAppInstanceHRDs("gitlab_client"):
        from IPython import embed
        print "DEBUG NOW create"
        embed()
        p
        

    import JumpScale.baselib.gitlab
    gl=j.clients.gitlab.get()
    from IPython import embed
    print "DEBUG NOW id"
    embed()
    


elif args.action == 'mdupdate':
    if j.application.sandbox:
        cmd="jssync download -c jpackages -d"
        j.system.process.executeWithoutPipe(cmd)
    else:
        if args.domain<>None:
            j.packages.updateMetaData(force=args.force,domain=args.domain)
        else:        
            j.packages.updateMetaData(force=args.force)

elif args.action == 'list':
    def printJPackages(packages):
        form = '%(domain)-15s %(name)-20s %(version)8s %(buildnr)8s %(debug)5s %(debugInJpackage)5s'
        print form % {'domain': 'DOMAIN', 'name': 'NAME', 'version': 'VERSION', 'debug': 'DEBUG', \
            'buildnr':'BUILDNR','debugInJpackage':'DEBUG_JP'}
        print '=' * 70
        print ''
        for package in sorted(packages, key=lambda p: "%s_%s" % (p.domain, p.name)):
            # debugINJP = 'yes' if package.getDebugModeInJpackage() else 'no'
            # debug = 'yes' if package.debug else 'no'
            debug="?"
            debugINJP="?"
            buildNr="?"
            version="?"
            print form % {'name': package.name, 'domain': package.domain, 'version': version, \
            'debug': debug, 'buildnr': buildNr,'debugInJpackage':debugINJP}

    jps=getJPackage(args,list=True,toinstall=args.installed)
    printJPackages(jps)

elif args.action == 'status':
    def printJPackages(packages):
        def sorter(jp1, jp2):
            prio1 = jp1.getPriority()
            prio2 = jp2.getPriority()
            if prio1 != prio2:
                return cmp(prio1, prio1)
            else:
                key1 = "%s_%s" % (jp1.domain, jp2.name)
                key2 = "%s_%s" % (jp2.domain, jp2.name)
                return cmp(key1, key2)

        form = '%(domain)-15s %(name)-20s %(instance)-10s %(prio)4s %(status)-8s %(ports)s'
        print form % {'domain': 'DOMAIN', 'name': 'NAME', 'instance': 'Instance', 'prio': 'Prio', 'status': 'Status', \
            'ports': 'Ports'}
        print '=' * 70
        print ''
        for package in sorted(packages, cmp=sorter):
            if not package.getProcessDicts():
                continue
            isrunning = package.actions.check_up_local(wait=False)
            status = 'RUNNING' if isrunning else 'HALTED'
            ports = ', '.join( str(x) for x in package.getTCPPorts() )
            print form % {'name': package.name, 'domain': package.domain, 'instance': package.instance, 'prio': package.getPriority(), 'status': status, 'ports': ports}

    jps = packages = getJPackage(args,expandInstances=True, installed=True, toinstall=True,list=True)
    printJPackages(jps)

j.application.stop()
